// Handpose ëª¨ë¸ ë° ë¹„ë””ì˜¤ ê´€ë ¨ ë³€ìˆ˜
let handpose;
let video;
let predictions = [];

// ë‹¤ì´ì•„ëª¬ë“œ(ë§ˆë¦„ëª¨) ê´€ë ¨ ë³€ìˆ˜
let diamonds = [];
let spreadCount = 0; // ì œìŠ¤ì²˜ íšŸìˆ˜ ì¹´ìš´í„°

// ì†ê°€ë½ í¼ì³ì§ ê°ì§€ë¥¼ ìœ„í•œ ë³€ìˆ˜ë“¤
let previousThumbPinkyDistance = 0;
let isSpreading = false;
let spreadThreshold = 50; // ì—„ì§€ì™€ ì•½ì§€ ì‚¬ì´ ê±°ë¦¬ê°€ ì´ë§Œí¼ ë©€ì–´ì ¸ì•¼ í¼ì³ì§ìœ¼ë¡œ ì¸ì‹
let spreadCooldown = 0; // í¼ì³ì§ ê°ì§€ í›„ ì¿¨ë‹¤ìš´
let spreadCooldownFrames = 60; // ì¿¨ë‹¤ìš´ í”„ë ˆì„ ìˆ˜ (ì•½ 1ì´ˆ)
let baselineDistance = 0; // ê¸°ì¤€ ê±°ë¦¬ (ì†ì˜ í¬ê¸°ì— ë”°ë¼ ì¡°ì •)
let isBaselineSet = false; // ê¸°ì¤€ ê±°ë¦¬ ì„¤ì • ì—¬ë¶€
let consecutiveFrames = 0; // ì—°ì†ìœ¼ë¡œ ê°ì§€ëœ í”„ë ˆì„ ìˆ˜ (ì‚¬ìš©í•˜ì§€ ì•ŠìŒ)
let stabilizationFrames = 0; // ì•ˆì •í™” í”„ë ˆì„ ìˆ˜
let requiredStabilizationFrames = 10; // ì•ˆì •í™”ì— í•„ìš”í•œ í”„ë ˆì„ ìˆ˜ (ë” ë¹ ë¥¸ ë°˜ì‘)
let baselineUpdateCounter = 0; // ê¸°ì¤€ê±°ë¦¬ ì—…ë°ì´íŠ¸ ì¹´ìš´í„°
let baselineUpdateInterval = 20; // 20í”„ë ˆì„ë§ˆë‹¤ ê¸°ì¤€ê±°ë¦¬ ì—…ë°ì´íŠ¸
let lastSpreadDistance = 0; // ë§ˆì§€ë§‰ ì†ê°€ë½ í¼ì³ì§ ì‹œì˜ ê±°ë¦¬
let baselineHistory = []; // ê¸°ì¤€ê±°ë¦¬ íˆìŠ¤í† ë¦¬ ë°°ì—´ (ì‚¬ìš©í•˜ì§€ ì•ŠìŒ)

// ì†Œë¦¬ ê°ì§€ ê´€ë ¨ ë³€ìˆ˜
let clapThreshold = 0.3 // ë°•ìˆ˜ ê°ì§€ ì„ê³„ê°’
let clapCooldown = 0; // ë°•ìˆ˜ ê°ì§€ í›„ ì¿¨ë‹¤ìš´
let clapCooldownFrames = 10; // ì¿¨ë‹¤ìš´ í”„ë ˆì„ ìˆ˜ (ë” ë¹ ë¥¸ ì—°ì† ê°ì§€)

// ì˜¤ë””ì˜¤ ê´€ë ¨ ë³€ìˆ˜ë“¤
let audioContext;
let audioAnalyser;
let audioDataArray;
let audioStream;

function setup() {
  createCanvas(windowWidth, windowHeight);
  
  // ì›¹ìº  ì„¤ì •
  video = createCapture(VIDEO, () => {
    // ì›¹ìº  ë¡œë”© í›„ ëª¨ë¸ ì´ˆê¸°í™”
    handpose = ml5.handpose(video, modelReady);
    handpose.on('predict', results => {
      predictions = results;
    });
  });
  video.size(640, 480);
  video.hide();
  
  // ë§ˆì´í¬ ìë™ ì‹œì‘
  startAudioCapture();
}

function modelReady() {
  console.log("Handpose ëª¨ë¸ ì¤€ë¹„ ì™„ë£Œ! ğŸ‘‹");
}

// ì˜¤ë””ì˜¤ ìº¡ì²˜ ì‹œì‘
function startAudioCapture() {
  navigator.mediaDevices.getUserMedia({ audio: true })
    .then(function(stream) {
      console.log("ë§ˆì´í¬ ì¤€ë¹„ ì™„ë£Œ! ğŸ¤");
      
      audioStream = stream;
      audioContext = new (window.AudioContext || window.webkitAudioContext)();
      const source = audioContext.createMediaStreamSource(stream);
      audioAnalyser = audioContext.createAnalyser();
      
      source.connect(audioAnalyser);
      audioAnalyser.fftSize = 256;
      
      const bufferLength = audioAnalyser.frequencyBinCount;
      audioDataArray = new Uint8Array(bufferLength);
      
      console.log("ì˜¤ë””ì˜¤ ìº¡ì²˜ ì‹œì‘ ì™„ë£Œ! ğŸ”Š");
    })
    .catch(function(err) {
      console.error("ë§ˆì´í¬ ì ‘ê·¼ ì˜¤ë¥˜:", err);
    });
}

function windowResized() {
  resizeCanvas(windowWidth, windowHeight);
}

function draw() {
  background(255);

  // 1. ì†ê°€ë½ í¼ì³ì§ ë™ì‘ ê°ì§€ ë° ë§ˆë¦„ëª¨ ìƒì„±
  if (predictions.length > 0) {
    const landmarks = predictions[0].landmarks;
    let fingersUp = [0, 0, 0, 0, 0];

    // ê° ì†ê°€ë½ì´ í´ì¡ŒëŠ”ì§€ í™•ì¸
    if (landmarks[8][1] < landmarks[6][1]) fingersUp[1] = 1; // ê²€ì§€
    if (landmarks[12][1] < landmarks[10][1]) fingersUp[2] = 1; // ì¤‘ì§€
    if (landmarks[16][1] < landmarks[14][1]) fingersUp[3] = 1; // ì•½ì§€
    if (landmarks[20][1] < landmarks[18][1]) fingersUp[4] = 1; // ìƒˆë¼
    if (landmarks[4][0] > landmarks[3][0]) fingersUp[0] = 1; // ì—„ì§€

    const totalFingers = fingersUp.reduce((total, finger) => total + finger, 0);
    
    // ì†ê°€ë½ì´ 3ê°œ ì´ìƒ í´ì§„ ê²½ìš°ì— í¼ì³ì§ ë™ì‘ ê°ì§€ (ë” ìœ ì—°í•˜ê²Œ)
    if (totalFingers >= 3) {
      // ì—„ì§€ì™€ ì•½ì§€(ìƒˆë¼ì†ê°€ë½) ì‚¬ì´ì˜ ê±°ë¦¬ ê³„ì‚°
      let thumbPos = [landmarks[4][0], landmarks[4][1]]; // ì—„ì§€ ëì 
      let pinkyPos = [landmarks[20][0], landmarks[20][1]]; // ì•½ì§€ ëì 
      let currentDistance = dist(thumbPos[0], thumbPos[1], pinkyPos[0], pinkyPos[1]);
      
      // ê°„ë‹¨í•œ ê¸°ì¤€ê±°ë¦¬ ë¡œì§ (ì•ˆì • ì²´í¬ ì œê±°)
      // ê¸°ì¤€ê±°ë¦¬ê°€ ì„¤ì •ë˜ì§€ ì•Šì•˜ìœ¼ë©´ ë°”ë¡œ ì„¤ì •
      if (!isBaselineSet) {
        baselineDistance = currentDistance;
        isBaselineSet = true;
        console.log("ê¸°ì¤€ê±°ë¦¬ ì„¤ì •:", baselineDistance.toFixed(1), "px");
      } else {
        // ê¸°ì¤€ê±°ë¦¬ë¥¼ ì ì§„ì ìœ¼ë¡œ ì—…ë°ì´íŠ¸ (ë…¸ì´ì¦ˆ ì œê±°)
        baselineDistance = baselineDistance * 0.95 + currentDistance * 0.05;
      }
      
      // 20í”„ë ˆì„ë§ˆë‹¤ ìƒíƒœ ë¡œê·¸
      if (baselineUpdateCounter % baselineUpdateInterval === 0) {
        let distanceChange = currentDistance - baselineDistance;
        let relativeChange = distanceChange / baselineDistance;
        console.log("í˜„ì¬ ê±°ë¦¬:", currentDistance.toFixed(1), "px, ê¸°ì¤€ê±°ë¦¬:", baselineDistance.toFixed(1), "px, ë³€í™”ìœ¨:", (relativeChange * 100).toFixed(1), "%");
      }
      baselineUpdateCounter++;

      // ê¸°ì¤€ ê±°ë¦¬ê°€ ì„¤ì •ëœ í›„ì—ë§Œ ê°ì§€ ì‹œì‘
      if (isBaselineSet) {
        // ì•ˆì •í™” ì‹œê°„ ëŒ€ê¸°
        stabilizationFrames++;
        
        // ë³€í™”ìœ¨ ê³„ì‚° (ì•ˆì •í™” ì™„ë£Œ ì—¬ë¶€ì™€ ê´€ê³„ì—†ì´)
        let distanceChange = currentDistance - baselineDistance;
        let relativeChange = distanceChange / baselineDistance; // ìƒëŒ€ì  ë³€í™”ìœ¨
        
        // ì´ì „ ê±°ë¦¬ì™€ì˜ ë³€í™”ëŸ‰ë„ ê³„ì‚°
        let frameChange = 0;
        if (previousThumbPinkyDistance > 0) {
          frameChange = currentDistance - previousThumbPinkyDistance;
        }
        
        // ì•ˆì •í™” í”„ë ˆì„ ì¡°ê±´ ì œê±°í•˜ê³  ë°”ë¡œ ê°ì§€ (ë” ë¹ ë¥¸ ë°˜ì‘)
        // ì¡°ê±´: ìƒëŒ€ì  ë³€í™”ìœ¨ì´ 75% ì´ìƒ + ë°©í–¥ì„± ì²´í¬ + ìµœì†Œ ê±°ë¦¬ ì„ê³„ê°’ + ìµœì†Œ ë³€í™”ëŸ‰
        let isSpreadingDetected = (relativeChange > 0.75) && 
                                 (currentDistance > previousThumbPinkyDistance) && // ë°©í–¥ì„± ì²´í¬: ì‹¤ì œë¡œ ëŠ˜ì–´ë‚˜ëŠ”ì§€
                                 (currentDistance > 50) && // ìµœì†Œ ê±°ë¦¬ ì„ê³„ê°’: ë„ˆë¬´ ì‘ì€ ê±°ë¦¬ì—ì„œëŠ” ê°ì§€í•˜ì§€ ì•ŠìŒ
                                 (Math.abs(currentDistance - previousThumbPinkyDistance) > 20) && // ìµœì†Œ ë³€í™”ëŸ‰: 20px ì´ìƒ
                                 !isSpreading && spreadCooldown === 0;
        
        // ì˜¤ë¯€ë¼ì„ ê°ì§€: ìƒëŒ€ì  ë³€í™”ìœ¨ì´ -60% ì´í•˜ + ë°©í–¥ì„± ì²´í¬ (ì¤„ì–´ë“œëŠ” ë°©í–¥) + ìµœì†Œ ë³€í™”ëŸ‰
        let isClosingDetected = (relativeChange < -0.60) && 
                               (currentDistance < previousThumbPinkyDistance) && // ë°©í–¥ì„± ì²´í¬: ì‹¤ì œë¡œ ì¤„ì–´ë“œëŠ”ì§€
                               (currentDistance > 10) && // ìµœì†Œ ê±°ë¦¬ ì„ê³„ê°’ (30px â†’ 10pxë¡œ ë‚®ì¶¤)
                               (Math.abs(currentDistance - previousThumbPinkyDistance) > 20) && // ìµœì†Œ ë³€í™”ëŸ‰: 20px ì´ìƒ
                               !isSpreading && spreadCooldown === 0;
        
        // ë””ë²„ê¹…: ì˜¤ë¯€ë¼ì„ ì¡°ê±´ì´ ê±°ì˜ ë§Œì¡±ë  ë•Œ ë¡œê·¸ ì¶œë ¥
        if (relativeChange < -0.50 && currentDistance < previousThumbPinkyDistance) {
          console.log("ì˜¤ë¯€ë¼ì„ ì¡°ê±´ ì²´í¬:", 
                     "ë³€í™”ìœ¨:", (relativeChange * 100).toFixed(1), "%", 
                     "ë°©í–¥ì„±:", (currentDistance < previousThumbPinkyDistance), 
                     "ìµœì†Œê±°ë¦¬:", (currentDistance > 30), 
                     "ì¿¨ë‹¤ìš´:", spreadCooldown);
        }
          
                                  if (isSpreadingDetected) {
              // ì¦‰ì‹œ í¼ì³ì§ìœ¼ë¡œ ì¸ì‹ (ì—°ì† í”„ë ˆì„ ì¡°ê±´ ì œê±°)
              isSpreading = true;
              spreadCount++;
              lastSpreadDistance = currentDistance; // ì†ê°€ë½ í¼ì³ì§ ì‹œì˜ ê±°ë¦¬ ì €ì¥
              console.log("ì†ì´ í¼ì³ì¡ŒìŠµë‹ˆë‹¤! âœ‹ (", spreadCount, "ë²ˆì§¸)");
              console.log("  - ê±°ë¦¬ ë³€í™”:", distanceChange.toFixed(1), "px");
              console.log("  - ìƒëŒ€ì  ë³€í™”:", (relativeChange * 100).toFixed(1), "%");
              console.log("  - ì´ì „ ê±°ë¦¬:", previousThumbPinkyDistance.toFixed(1), "px");
              console.log("  - í˜„ì¬ ê±°ë¦¬:", currentDistance.toFixed(1), "px");
              console.log("  - ë°©í–¥ì„± ì²´í¬: âœ… ëŠ˜ì–´ë‚¨");
              spreadCooldown = spreadCooldownFrames;
            } else if (isClosingDetected) {
              // ì¦‰ì‹œ ì˜¤ë¯€ë¼ì„ìœ¼ë¡œ ì¸ì‹ (ì—°ì† í”„ë ˆì„ ì¡°ê±´ ì œê±°)
              console.log("ì†ì´ ì˜¤ë¯€ë¼ì¡ŒìŠµë‹ˆë‹¤! ğŸ¤");
              console.log("  - ê±°ë¦¬ ë³€í™”:", distanceChange.toFixed(1), "px");
              console.log("  - ìƒëŒ€ì  ë³€í™”:", (relativeChange * 100).toFixed(1), "%");
              console.log("  - ì´ì „ ê±°ë¦¬:", previousThumbPinkyDistance.toFixed(1), "px");
              console.log("  - í˜„ì¬ ê±°ë¦¬:", currentDistance.toFixed(1), "px");
              console.log("  - ë°©í–¥ì„± ì²´í¬: âœ… ì¤„ì–´ë“¦");
              console.log("  - ì˜¤ë¯€ë¼ì„ ì¡°ê±´: ë³€í™”ìœ¨ < -50%");
              
              // ë°•ìˆ˜ì²˜ëŸ¼ ìµœê·¼ ë§ˆë¦„ëª¨ë“¤ ì‚­ì œ
              shrinkLatestDiamonds();
              spreadCooldown = spreadCooldownFrames;
            }
      }
      
      // í˜„ì¬ ê±°ë¦¬ë¥¼ ì´ì „ ê±°ë¦¬ë¡œ ì €ì¥
      previousThumbPinkyDistance = currentDistance;
      
      // í¼ì³ì§ì´ ê°ì§€ë˜ë©´ ë§ˆë¦„ëª¨ë“¤ ìƒì„±
      if (isSpreading) {
        generateDiamondGrid(spreadCount, landmarks);
        isSpreading = false; // ìƒíƒœ ì´ˆê¸°í™”
        
        // ì†ê°€ë½ì´ í¼ì³ì§„ í›„ ê¸°ì¤€ê±°ë¦¬ëŠ” ìœ ì§€ (ì¬ì„¤ì •í•˜ì§€ ì•ŠìŒ)
        // ì´ë ‡ê²Œ í•˜ë©´ ì†ê°€ë½ì„ ì ‘ì—ˆë‹¤ í´ëŠ” ë™ì‘ì—ì„œ ì˜¤ì¸ì„ ë°©ì§€
        console.log("í¼ì³ì§ ì™„ë£Œ - ê¸°ì¤€ê±°ë¦¬ ìœ ì§€:", baselineDistance.toFixed(1), "px");
      }
    } else {
      // ì†ê°€ë½ì´ 3ê°œ ë¯¸ë§Œì´ë©´ í¼ì³ì§ ìƒíƒœ ì´ˆê¸°í™”
      isSpreading = false;
      consecutiveFrames = 0;
      stabilizationFrames = 0; // ì•ˆì •í™” ì‹œê°„ë„ ë¦¬ì…‹
      // ê¸°ì¤€ê±°ë¦¬ ì—…ë°ì´íŠ¸ ì¹´ìš´í„°ëŠ” ê³„ì† ì¦ê°€ (ì†ì„ ì ê¹ ì ‘ì—ˆë‹¤ í´ëŠ” ê²½ìš° ëŒ€ì‘)
      baselineUpdateCounter++;
    }
  } else {
    // ì†ì´ ì¸ì‹ë˜ì§€ ì•Šìœ¼ë©´ í¼ì³ì§ ìƒíƒœ ì´ˆê¸°í™”
    isSpreading = false;
    consecutiveFrames = 0;
    stabilizationFrames = 0; // ì•ˆì •í™” ì‹œê°„ë„ ë¦¬ì…‹
    // ê¸°ì¤€ê±°ë¦¬ ì—…ë°ì´íŠ¸ ì¹´ìš´í„°ëŠ” ê³„ì† ì¦ê°€ (ì†ì´ ì ê¹ ì‚¬ë¼ì¡Œë‹¤ê°€ ë‹¤ì‹œ ë‚˜íƒ€ë‚˜ëŠ” ê²½ìš° ëŒ€ì‘)
    baselineUpdateCounter++;
  }
  
  // ì¿¨ë‹¤ìš´ ê°ì†Œ
  if (spreadCooldown > 0) {
    spreadCooldown--;
  }

  // 2. ë°•ìˆ˜ ì†Œë¦¬ ê°ì§€
  detectClap();

  // 3. ëª¨ë“  ë§ˆë¦„ëª¨ ì—…ë°ì´íŠ¸ ë° ê·¸ë¦¬ê¸°
  updateAndDrawDiamonds();

  // 4. ì†ê°€ë½ í¬ì¸í„° ê·¸ë¦¬ê¸° (ë§ˆë¦„ëª¨ ìœ„ì— í‘œì‹œ)
  checkFingers(predictions, video);
}



function generateDiamondGrid(id, landmarks) {
  let maxDistance = 0;
  for (let i = 0; i < 5; i++) {
    for (let j = i + 1; j < 5; j++) {
      const finger1 = landmarks[4 + i * 4];
      const finger2 = landmarks[4 + j * 4];
      const d = dist(finger1[0], finger1[1], finger2[0], finger2[1]);
      if (d > maxDistance) {
        maxDistance = d;
      }
    }
  }

  const diamondSize = map(maxDistance, 30, 400, 10, 80);
  const margin = -50; // ìŒìˆ˜ ë§ˆì§„ìœ¼ë¡œ í™”ë©´ ë°–ê¹Œì§€ ìƒì„±
  const spacing = diamondSize * 2.2;

  const cols = floor((width - margin * 2) / spacing);
  const rows = floor((height - margin * 2) / spacing);

  const gridWidth = (cols - 1) * spacing;
  const gridHeight = (rows - 1) * spacing;
  const startX = (width - gridWidth) / 2;
  const startY = (height - gridHeight) / 2;

  for (let i = 0; i < cols; i++) {
    for (let j = 0; j < rows; j++) {
      const x = startX + i * spacing;
      const y = startY + j * spacing;
      const diamond = new Diamond(x, y, diamondSize, id);
      diamond.startAnimation();
      diamonds.push(diamond);
    }
  }
}

/**
 * @brief ë°•ìˆ˜ ì†Œë¦¬ë¥¼ ê°ì§€í•˜ì—¬ ìµœê·¼ ë§ˆë¦„ëª¨ë“¤ì„ ì‚­ì œí•©ë‹ˆë‹¤.
 */
function detectClap() {
  if (!audioAnalyser || !audioDataArray) {
    return;
  }
  
  if (clapCooldown > 0) {
    clapCooldown--;
    return;
  }
  
  // ì†Œë¦¬ ë ˆë²¨ ì¸¡ì •
  audioAnalyser.getByteFrequencyData(audioDataArray);
  let sum = 0;
  for (let i = 0; i < audioDataArray.length; i++) {
    sum += audioDataArray[i];
  }
  let level = sum / audioDataArray.length / 255; // 0-1 ë²”ìœ„ë¡œ ì •ê·œí™”
  
  // ë””ë²„ê¹…: ì†Œë¦¬ ë ˆë²¨ ì¶œë ¥ (ë°•ìˆ˜ ê°ì§€ ì‹œì—ë§Œ)
  if (level > clapThreshold * 0.8) {
    console.log("ì†Œë¦¬ ë ˆë²¨:", level.toFixed(3));
  }
  
  if (level > clapThreshold) {
    console.log("ë°•ìˆ˜ ê°ì§€! ğŸ‘ (ë ˆë²¨:", level.toFixed(3), ")");
    shrinkLatestDiamonds();
    clapCooldown = clapCooldownFrames;
  }
}

function shrinkLatestDiamonds() {
  if (diamonds.length === 0) return;

  // ê°€ì¥ ìµœì‹  ë²ˆí˜¸ ì°¾ê¸°
  let maxSpreadNumber = -1;
  for (let diamond of diamonds) {
    if (diamond.spreadNumber > maxSpreadNumber) {
      maxSpreadNumber = diamond.spreadNumber;
    }
  }

  // ê°™ì€ ìµœì‹  ë²ˆí˜¸ì˜ ëª¨ë“  ë§ˆë¦„ëª¨ë“¤ ì‚­ì œ
  for (let diamond of diamonds) {
    if (diamond.spreadNumber === maxSpreadNumber && !diamond.isShrinking) {
      diamond.startShrinking();
    }
  }
}

function updateAndDrawDiamonds() {
  diamonds = diamonds.filter(diamond => !diamond.shouldDelete);

  for (let diamond of diamonds) {
    diamond.update();
    diamond.draw();
  }
}

function easeInOutExpo(x) {
  return x === 0 ? 0 : x === 1 ? 1 : x < 0.5 ? Math.pow(2, 20 * x - 10) / 2 : (2 - Math.pow(2, -20 * x + 10)) / 2;
}

class Diamond {
  constructor(centerX, centerY, size, spreadNumber) {
    this.centerX = centerX;
    this.centerY = centerY;
    this.size = size;
    this.spreadNumber = spreadNumber;
    this.currentSize = 0;
    this.targetSize = size;
    this.animationTime = 0;
    this.animationDuration = 60;
    this.isAnimating = false;
    this.isShrinking = false;
    this.shouldDelete = false;
  }

  draw() {
    push();
    fill(0);
    noStroke();
    translate(this.centerX, this.centerY);
    rotate(PI / 4);
    rectMode(CENTER);
    rect(0, 0, this.currentSize * 1.5, this.currentSize * 1.5);
    pop();
  }

  startAnimation() {
    this.isAnimating = true;
    this.animationTime = 0;
  }

  startShrinking() {
    this.isShrinking = true;
    this.animationTime = 0;
    this.targetSize = this.currentSize;
  }

  update() {
    if (this.isAnimating) {
      this.animationTime++;
      let progress = this.animationTime / this.animationDuration;
      if (progress >= 1) {
        progress = 1;
        this.isAnimating = false;
      }
      this.currentSize = lerp(0, this.targetSize, easeInOutExpo(progress));
    }

    if (this.isShrinking) {
      this.animationTime++;
      let progress = this.animationTime / this.animationDuration;
      if (progress >= 1) {
        progress = 1;
        this.isShrinking = false;
        this.shouldDelete = true;
      }
      this.currentSize = lerp(this.targetSize, 0, easeInOutExpo(progress));
    }
  }
}
