// Handpose 모델 및 비디오 관련 변수
let handpose;
let video;
let predictions = [];

// 다이아몬드(마름모) 관련 변수
let diamonds = [];
let spreadCount = 0; // 제스처 횟수 카운터

// 손가락 펼쳐짐 감지를 위한 변수들
let previousThumbPinkyDistance = 0;
let isSpreading = false;
let spreadThreshold = 50; // 엄지와 약지 사이 거리가 이만큼 멀어져야 펼쳐짐으로 인식
let spreadCooldown = 0; // 펼쳐짐 감지 후 쿨다운
let spreadCooldownFrames = 60; // 쿨다운 프레임 수 (약 1초)
let baselineDistance = 0; // 기준 거리 (손의 크기에 따라 조정)
let isBaselineSet = false; // 기준 거리 설정 여부
let consecutiveFrames = 0; // 연속으로 감지된 프레임 수 (사용하지 않음)
let stabilizationFrames = 0; // 안정화 프레임 수
let requiredStabilizationFrames = 10; // 안정화에 필요한 프레임 수 (더 빠른 반응)
let baselineUpdateCounter = 0; // 기준거리 업데이트 카운터
let baselineUpdateInterval = 20; // 20프레임마다 기준거리 업데이트
let lastSpreadDistance = 0; // 마지막 손가락 펼쳐짐 시의 거리
let baselineHistory = []; // 기준거리 히스토리 배열 (사용하지 않음)

// 소리 감지 관련 변수
let clapThreshold = 0.3 // 박수 감지 임계값
let clapCooldown = 0; // 박수 감지 후 쿨다운
let clapCooldownFrames = 10; // 쿨다운 프레임 수 (더 빠른 연속 감지)

// 오디오 관련 변수들
let audioContext;
let audioAnalyser;
let audioDataArray;
let audioStream;

function setup() {
  createCanvas(windowWidth, windowHeight);
  
  // 웹캠 설정
  video = createCapture(VIDEO, () => {
    // 웹캠 로딩 후 모델 초기화
    handpose = ml5.handpose(video, modelReady);
    handpose.on('predict', results => {
      predictions = results;
    });
  });
  video.size(640, 480);
  video.hide();
  
  // 마이크 자동 시작
  startAudioCapture();
}

function modelReady() {
  console.log("Handpose 모델 준비 완료! 👋");
}

// 오디오 캡처 시작
function startAudioCapture() {
  navigator.mediaDevices.getUserMedia({ audio: true })
    .then(function(stream) {
      console.log("마이크 준비 완료! 🎤");
      
      audioStream = stream;
      audioContext = new (window.AudioContext || window.webkitAudioContext)();
      const source = audioContext.createMediaStreamSource(stream);
      audioAnalyser = audioContext.createAnalyser();
      
      source.connect(audioAnalyser);
      audioAnalyser.fftSize = 256;
      
      const bufferLength = audioAnalyser.frequencyBinCount;
      audioDataArray = new Uint8Array(bufferLength);
      
      console.log("오디오 캡처 시작 완료! 🔊");
    })
    .catch(function(err) {
      console.error("마이크 접근 오류:", err);
    });
}

function windowResized() {
  resizeCanvas(windowWidth, windowHeight);
}

function draw() {
  background(255);

  // 1. 손가락 펼쳐짐 동작 감지 및 마름모 생성
  if (predictions.length > 0) {
    const landmarks = predictions[0].landmarks;
    let fingersUp = [0, 0, 0, 0, 0];

    // 각 손가락이 펴졌는지 확인
    if (landmarks[8][1] < landmarks[6][1]) fingersUp[1] = 1; // 검지
    if (landmarks[12][1] < landmarks[10][1]) fingersUp[2] = 1; // 중지
    if (landmarks[16][1] < landmarks[14][1]) fingersUp[3] = 1; // 약지
    if (landmarks[20][1] < landmarks[18][1]) fingersUp[4] = 1; // 새끼
    if (landmarks[4][0] > landmarks[3][0]) fingersUp[0] = 1; // 엄지

    const totalFingers = fingersUp.reduce((total, finger) => total + finger, 0);
    
    // 손가락이 3개 이상 펴진 경우에 펼쳐짐 동작 감지 (더 유연하게)
    if (totalFingers >= 3) {
      // 엄지와 약지(새끼손가락) 사이의 거리 계산
      let thumbPos = [landmarks[4][0], landmarks[4][1]]; // 엄지 끝점
      let pinkyPos = [landmarks[20][0], landmarks[20][1]]; // 약지 끝점
      let currentDistance = dist(thumbPos[0], thumbPos[1], pinkyPos[0], pinkyPos[1]);
      
      // 간단한 기준거리 로직 (안정 체크 제거)
      // 기준거리가 설정되지 않았으면 바로 설정
      if (!isBaselineSet) {
        baselineDistance = currentDistance;
        isBaselineSet = true;
        console.log("기준거리 설정:", baselineDistance.toFixed(1), "px");
      } else {
        // 기준거리를 점진적으로 업데이트 (노이즈 제거)
        baselineDistance = baselineDistance * 0.95 + currentDistance * 0.05;
      }
      
      // 20프레임마다 상태 로그
      if (baselineUpdateCounter % baselineUpdateInterval === 0) {
        let distanceChange = currentDistance - baselineDistance;
        let relativeChange = distanceChange / baselineDistance;
        console.log("현재 거리:", currentDistance.toFixed(1), "px, 기준거리:", baselineDistance.toFixed(1), "px, 변화율:", (relativeChange * 100).toFixed(1), "%");
      }
      baselineUpdateCounter++;

      // 기준 거리가 설정된 후에만 감지 시작
      if (isBaselineSet) {
        // 안정화 시간 대기
        stabilizationFrames++;
        
        // 변화율 계산 (안정화 완료 여부와 관계없이)
        let distanceChange = currentDistance - baselineDistance;
        let relativeChange = distanceChange / baselineDistance; // 상대적 변화율
        
        // 이전 거리와의 변화량도 계산
        let frameChange = 0;
        if (previousThumbPinkyDistance > 0) {
          frameChange = currentDistance - previousThumbPinkyDistance;
        }
        
        // 안정화 프레임 조건 제거하고 바로 감지 (더 빠른 반응)
        // 조건: 상대적 변화율이 75% 이상 + 방향성 체크 + 최소 거리 임계값 + 최소 변화량
        let isSpreadingDetected = (relativeChange > 0.75) && 
                                 (currentDistance > previousThumbPinkyDistance) && // 방향성 체크: 실제로 늘어나는지
                                 (currentDistance > 50) && // 최소 거리 임계값: 너무 작은 거리에서는 감지하지 않음
                                 (Math.abs(currentDistance - previousThumbPinkyDistance) > 20) && // 최소 변화량: 20px 이상
                                 !isSpreading && spreadCooldown === 0;
        
        // 오므라임 감지: 상대적 변화율이 -60% 이하 + 방향성 체크 (줄어드는 방향) + 최소 변화량
        let isClosingDetected = (relativeChange < -0.60) && 
                               (currentDistance < previousThumbPinkyDistance) && // 방향성 체크: 실제로 줄어드는지
                               (currentDistance > 10) && // 최소 거리 임계값 (30px → 10px로 낮춤)
                               (Math.abs(currentDistance - previousThumbPinkyDistance) > 20) && // 최소 변화량: 20px 이상
                               !isSpreading && spreadCooldown === 0;
        
        // 디버깅: 오므라임 조건이 거의 만족될 때 로그 출력
        if (relativeChange < -0.50 && currentDistance < previousThumbPinkyDistance) {
          console.log("오므라임 조건 체크:", 
                     "변화율:", (relativeChange * 100).toFixed(1), "%", 
                     "방향성:", (currentDistance < previousThumbPinkyDistance), 
                     "최소거리:", (currentDistance > 30), 
                     "쿨다운:", spreadCooldown);
        }
          
                                  if (isSpreadingDetected) {
              // 즉시 펼쳐짐으로 인식 (연속 프레임 조건 제거)
              isSpreading = true;
              spreadCount++;
              lastSpreadDistance = currentDistance; // 손가락 펼쳐짐 시의 거리 저장
              console.log("손이 펼쳐졌습니다! ✋ (", spreadCount, "번째)");
              console.log("  - 거리 변화:", distanceChange.toFixed(1), "px");
              console.log("  - 상대적 변화:", (relativeChange * 100).toFixed(1), "%");
              console.log("  - 이전 거리:", previousThumbPinkyDistance.toFixed(1), "px");
              console.log("  - 현재 거리:", currentDistance.toFixed(1), "px");
              console.log("  - 방향성 체크: ✅ 늘어남");
              spreadCooldown = spreadCooldownFrames;
            } else if (isClosingDetected) {
              // 즉시 오므라임으로 인식 (연속 프레임 조건 제거)
              console.log("손이 오므라졌습니다! 🤏");
              console.log("  - 거리 변화:", distanceChange.toFixed(1), "px");
              console.log("  - 상대적 변화:", (relativeChange * 100).toFixed(1), "%");
              console.log("  - 이전 거리:", previousThumbPinkyDistance.toFixed(1), "px");
              console.log("  - 현재 거리:", currentDistance.toFixed(1), "px");
              console.log("  - 방향성 체크: ✅ 줄어듦");
              console.log("  - 오므라임 조건: 변화율 < -50%");
              
              // 박수처럼 최근 마름모들 삭제
              shrinkLatestDiamonds();
              spreadCooldown = spreadCooldownFrames;
            }
      }
      
      // 현재 거리를 이전 거리로 저장
      previousThumbPinkyDistance = currentDistance;
      
      // 펼쳐짐이 감지되면 마름모들 생성
      if (isSpreading) {
        generateDiamondGrid(spreadCount, landmarks);
        isSpreading = false; // 상태 초기화
        
        // 손가락이 펼쳐진 후 기준거리는 유지 (재설정하지 않음)
        // 이렇게 하면 손가락을 접었다 펴는 동작에서 오인을 방지
        console.log("펼쳐짐 완료 - 기준거리 유지:", baselineDistance.toFixed(1), "px");
      }
    } else {
      // 손가락이 3개 미만이면 펼쳐짐 상태 초기화
      isSpreading = false;
      consecutiveFrames = 0;
      stabilizationFrames = 0; // 안정화 시간도 리셋
      // 기준거리 업데이트 카운터는 계속 증가 (손을 잠깐 접었다 펴는 경우 대응)
      baselineUpdateCounter++;
    }
  } else {
    // 손이 인식되지 않으면 펼쳐짐 상태 초기화
    isSpreading = false;
    consecutiveFrames = 0;
    stabilizationFrames = 0; // 안정화 시간도 리셋
    // 기준거리 업데이트 카운터는 계속 증가 (손이 잠깐 사라졌다가 다시 나타나는 경우 대응)
    baselineUpdateCounter++;
  }
  
  // 쿨다운 감소
  if (spreadCooldown > 0) {
    spreadCooldown--;
  }

  // 2. 박수 소리 감지
  detectClap();

  // 3. 모든 마름모 업데이트 및 그리기
  updateAndDrawDiamonds();

  // 4. 손가락 포인터 그리기 (마름모 위에 표시)
  checkFingers(predictions, video);
}



function generateDiamondGrid(id, landmarks) {
  let maxDistance = 0;
  for (let i = 0; i < 5; i++) {
    for (let j = i + 1; j < 5; j++) {
      const finger1 = landmarks[4 + i * 4];
      const finger2 = landmarks[4 + j * 4];
      const d = dist(finger1[0], finger1[1], finger2[0], finger2[1]);
      if (d > maxDistance) {
        maxDistance = d;
      }
    }
  }

  const diamondSize = map(maxDistance, 30, 400, 10, 80);
  const margin = -50; // 음수 마진으로 화면 밖까지 생성
  const spacing = diamondSize * 2.2;

  const cols = floor((width - margin * 2) / spacing);
  const rows = floor((height - margin * 2) / spacing);

  const gridWidth = (cols - 1) * spacing;
  const gridHeight = (rows - 1) * spacing;
  const startX = (width - gridWidth) / 2;
  const startY = (height - gridHeight) / 2;

  for (let i = 0; i < cols; i++) {
    for (let j = 0; j < rows; j++) {
      const x = startX + i * spacing;
      const y = startY + j * spacing;
      const diamond = new Diamond(x, y, diamondSize, id);
      diamond.startAnimation();
      diamonds.push(diamond);
    }
  }
}

/**
 * @brief 박수 소리를 감지하여 최근 마름모들을 삭제합니다.
 */
function detectClap() {
  if (!audioAnalyser || !audioDataArray) {
    return;
  }
  
  if (clapCooldown > 0) {
    clapCooldown--;
    return;
  }
  
  // 소리 레벨 측정
  audioAnalyser.getByteFrequencyData(audioDataArray);
  let sum = 0;
  for (let i = 0; i < audioDataArray.length; i++) {
    sum += audioDataArray[i];
  }
  let level = sum / audioDataArray.length / 255; // 0-1 범위로 정규화
  
  // 디버깅: 소리 레벨 출력 (박수 감지 시에만)
  if (level > clapThreshold * 0.8) {
    console.log("소리 레벨:", level.toFixed(3));
  }
  
  if (level > clapThreshold) {
    console.log("박수 감지! 👏 (레벨:", level.toFixed(3), ")");
    shrinkLatestDiamonds();
    clapCooldown = clapCooldownFrames;
  }
}

function shrinkLatestDiamonds() {
  if (diamonds.length === 0) return;

  // 가장 최신 번호 찾기
  let maxSpreadNumber = -1;
  for (let diamond of diamonds) {
    if (diamond.spreadNumber > maxSpreadNumber) {
      maxSpreadNumber = diamond.spreadNumber;
    }
  }

  // 같은 최신 번호의 모든 마름모들 삭제
  for (let diamond of diamonds) {
    if (diamond.spreadNumber === maxSpreadNumber && !diamond.isShrinking) {
      diamond.startShrinking();
    }
  }
}

function updateAndDrawDiamonds() {
  diamonds = diamonds.filter(diamond => !diamond.shouldDelete);

  for (let diamond of diamonds) {
    diamond.update();
    diamond.draw();
  }
}

function easeInOutExpo(x) {
  return x === 0 ? 0 : x === 1 ? 1 : x < 0.5 ? Math.pow(2, 20 * x - 10) / 2 : (2 - Math.pow(2, -20 * x + 10)) / 2;
}

class Diamond {
  constructor(centerX, centerY, size, spreadNumber) {
    this.centerX = centerX;
    this.centerY = centerY;
    this.size = size;
    this.spreadNumber = spreadNumber;
    this.currentSize = 0;
    this.targetSize = size;
    this.animationTime = 0;
    this.animationDuration = 60;
    this.isAnimating = false;
    this.isShrinking = false;
    this.shouldDelete = false;
  }

  draw() {
    push();
    fill(0);
    noStroke();
    translate(this.centerX, this.centerY);
    rotate(PI / 4);
    rectMode(CENTER);
    rect(0, 0, this.currentSize * 1.5, this.currentSize * 1.5);
    pop();
  }

  startAnimation() {
    this.isAnimating = true;
    this.animationTime = 0;
  }

  startShrinking() {
    this.isShrinking = true;
    this.animationTime = 0;
    this.targetSize = this.currentSize;
  }

  update() {
    if (this.isAnimating) {
      this.animationTime++;
      let progress = this.animationTime / this.animationDuration;
      if (progress >= 1) {
        progress = 1;
        this.isAnimating = false;
      }
      this.currentSize = lerp(0, this.targetSize, easeInOutExpo(progress));
    }

    if (this.isShrinking) {
      this.animationTime++;
      let progress = this.animationTime / this.animationDuration;
      if (progress >= 1) {
        progress = 1;
        this.isShrinking = false;
        this.shouldDelete = true;
      }
      this.currentSize = lerp(this.targetSize, 0, easeInOutExpo(progress));
    }
  }
}
