#ì†ê°€ë½ ì˜¤ë¯€ë¦¬ê¸° í´ê¸° ë°•ìˆ˜ êµ¬í˜„ ì™„ë£Œ
// ========================================
// ì„¤ì • ì„¹ì…˜ - ì—¬ê¸°ì„œ ê°’ë“¤ì„ ì‰½ê²Œ ë³€ê²½í•˜ì„¸ìš”!
// ========================================

// ì†ê°€ë½ ê°ì§€ ì„¤ì •
const FINGER_DETECTION = {
  // í¼ì¹˜ê¸° ê°ì§€ ì„ê³„ê°’ (ê¸°ì¤€ê±°ë¦¬ë³„)
  SPREAD_THRESHOLD_MIN: 0.80,    // ê¸°ì¤€ê±°ë¦¬ â‰¤ 50pxì¼ ë•Œ (80%)
  SPREAD_THRESHOLD_MAX: 0.30,    // ê¸°ì¤€ê±°ë¦¬ â‰¥ 150pxì¼ ë•Œ (30%)
  
  // ì˜¤ë¯€ë¼ì„ ê°ì§€ ì„ê³„ê°’ (ê¸°ì¤€ê±°ë¦¬ë³„)
  CLOSE_THRESHOLD_MIN: 0.80,     // ê¸°ì¤€ê±°ë¦¬ â‰¤ 50pxì¼ ë•Œ (80%)
  CLOSE_THRESHOLD_MAX: 0.60,     // ê¸°ì¤€ê±°ë¦¬ â‰¥ 150pxì¼ ë•Œ (60%)
  
  // ìµœì†Œ ê±°ë¦¬ ë° ë³€í™”ëŸ‰
  MIN_DISTANCE: 50,              // ìµœì†Œ ê±°ë¦¬ ì„ê³„ê°’ (px)
  MIN_CHANGE: 20,                // ìµœì†Œ ë³€í™”ëŸ‰ (px)
  MIN_CLOSE_DISTANCE: 10,        // ì˜¤ë¯€ë¼ì„ ìµœì†Œ ê±°ë¦¬ (px)
  
  // ì¿¨ë‹¤ìš´ ì„¤ì •
  SPREAD_COOLDOWN_FRAMES: 60,    // í¼ì¹˜ê¸° ê°ì§€ í›„ ì¿¨ë‹¤ìš´ (ì•½ 1ì´ˆ)
  
  // ê¸°ì¤€ê±°ë¦¬ ë²”ìœ„
  BASELINE_MIN: 50,              // ìµœì†Œ ê¸°ì¤€ê±°ë¦¬ (px)
  BASELINE_MAX: 150,             // ìµœëŒ€ ê¸°ì¤€ê±°ë¦¬ (px)
};

// ë§ˆë¦„ëª¨ ìƒì„± ì„¤ì •
const DIAMOND_GENERATION = {
  // ë§ˆë¦„ëª¨ í¬ê¸° ì„¤ì •
  MIN_SIZE: 3,                   // ìµœì†Œ ë§ˆë¦„ëª¨ í¬ê¸° (px)
  MAX_SIZE_RATIO: 7,             // ìµœëŒ€ í¬ê¸° (í™”ë©´ ê°€ë¡œ / 7)
  MIN_DISTANCE_MAP: 50,          // ë§¤í•‘ ìµœì†Œ ê±°ë¦¬ (px)
  MAX_DISTANCE_MAP: 400,         // ë§¤í•‘ ìµœëŒ€ ê±°ë¦¬ (px)
  
  // ê±°ë¦¬ ê°€ì¤‘ì¹˜ (ê¸°ì¤€ê±°ë¦¬ : í¼ì¹œê±°ë¦¬)
  BASELINE_WEIGHT: 0.6,          // ê¸°ì¤€ê±°ë¦¬ ê°€ì¤‘ì¹˜
  SPREAD_WEIGHT: 0.4,            // í¼ì¹œê±°ë¦¬ ê°€ì¤‘ì¹˜
  
  // ê·¸ë¦¬ë“œ ì„¤ì •
  SPACING_MULTIPLIER: 2.2,       // ë§ˆë¦„ëª¨ ê°„ê²© ë°°ìˆ˜
  MARGIN: -50,                   // í™”ë©´ ë°– ë§ˆì§„ (px)
};

// ë°•ìˆ˜ ê°ì§€ ì„¤ì •
const CLAP_DETECTION = {
  THRESHOLD: 0.28,               // ë°•ìˆ˜ ê°ì§€ ì„ê³„ê°’
  COOLDOWN_FRAMES: 60,           // ë°•ìˆ˜ ê°ì§€ í›„ ì¿¨ë‹¤ìš´ (ì•½ 1ì´ˆ)
  SHRINK_INTERVAL: 15,           // ë°•ìˆ˜ ì‚­ì œ ê°„ê²© (í”„ë ˆì„)
};

// ìˆœì°¨ ì‚­ì œ ì„¤ì •
const SEQUENTIAL_DELETION = {
  SHRINK_INTERVAL: 3,            // ìˆœì°¨ ì‚­ì œ ê°„ê²© (í”„ë ˆì„)
};

// ì• ë‹ˆë©”ì´ì…˜ ì„¤ì •
const ANIMATION = {
  DURATION: 60,                  // ì• ë‹ˆë©”ì´ì…˜ ì§€ì† ì‹œê°„ (í”„ë ˆì„)
};

// ========================================
// ê¸°ì¡´ ë³€ìˆ˜ë“¤ (ì„¤ì •ê°’ ì‚¬ìš©)
// ========================================

// Handpose ëª¨ë¸ ë° ë¹„ë””ì˜¤ ê´€ë ¨ ë³€ìˆ˜
let handpose;
let video;
let predictions = [];

// ë‹¤ì´ì•„ëª¬ë“œ(ë§ˆë¦„ëª¨) ê´€ë ¨ ë³€ìˆ˜
let diamonds = [];
let spreadCount = 0; // ì œìŠ¤ì²˜ íšŸìˆ˜ ì¹´ìš´í„°

// ìˆœì°¨ì  ì‚­ì œë¥¼ ìœ„í•œ ë³€ìˆ˜
let diamondsToShrink = [];
let shrinkInterval = SEQUENTIAL_DELETION.SHRINK_INTERVAL; // ì„¤ì •ê°’ ì‚¬ìš©
let shrinkCounter = 0;

// ì†ê°€ë½ í¼ì³ì§ ê°ì§€ë¥¼ ìœ„í•œ ë³€ìˆ˜ë“¤
let previousThumbPinkyDistance = 0;
let isSpreading = false;
let spreadThreshold = 50; // ì—„ì§€ì™€ ì•½ì§€ ì‚¬ì´ ê±°ë¦¬ê°€ ì´ë§Œí¼ ë©€ì–´ì ¸ì•¼ í¼ì³ì§ìœ¼ë¡œ ì¸ì‹
let spreadCooldown = 0; // í¼ì³ì§ ê°ì§€ í›„ ì¿¨ë‹¤ìš´
let spreadCooldownFrames = FINGER_DETECTION.SPREAD_COOLDOWN_FRAMES; // ì„¤ì •ê°’ ì‚¬ìš©
let baselineDistance = 0; // ê¸°ì¤€ ê±°ë¦¬ (ì†ì˜ í¬ê¸°ì— ë”°ë¼ ì¡°ì •)
let isBaselineSet = false; // ê¸°ì¤€ ê±°ë¦¬ ì„¤ì • ì—¬ë¶€
let consecutiveFrames = 0; // ì—°ì†ìœ¼ë¡œ ê°ì§€ëœ í”„ë ˆì„ ìˆ˜ (ì‚¬ìš©í•˜ì§€ ì•ŠìŒ)
let stabilizationFrames = 0; // ì•ˆì •í™” í”„ë ˆì„ ìˆ˜
let requiredStabilizationFrames = 10; // ì•ˆì •í™”ì— í•„ìš”í•œ í”„ë ˆì„ ìˆ˜ (ë” ë¹ ë¥¸ ë°˜ì‘)
let baselineUpdateCounter = 0; // ê¸°ì¤€ê±°ë¦¬ ì—…ë°ì´íŠ¸ ì¹´ìš´í„°
let baselineUpdateInterval = 20; // 20í”„ë ˆì„ë§ˆë‹¤ ê¸°ì¤€ê±°ë¦¬ ì—…ë°ì´íŠ¸
let lastSpreadDistance = 0; // ë§ˆì§€ë§‰ ì†ê°€ë½ í¼ì³ì§ ì‹œì˜ ê±°ë¦¬
let baselineHistory = []; // ê¸°ì¤€ê±°ë¦¬ íˆìŠ¤í† ë¦¬ ë°°ì—´ (ì‚¬ìš©í•˜ì§€ ì•ŠìŒ)

// ì†Œë¦¬ ê°ì§€ ê´€ë ¨ ë³€ìˆ˜
let clapThreshold = CLAP_DETECTION.THRESHOLD; // ì„¤ì •ê°’ ì‚¬ìš©
let clapCooldown = 0; // ë°•ìˆ˜ ê°ì§€ í›„ ì¿¨ë‹¤ìš´
let clapCooldownFrames = CLAP_DETECTION.COOLDOWN_FRAMES; // ì„¤ì •ê°’ ì‚¬ìš©
let isClapShrinking = false; // ë°•ìˆ˜ë¡œ ì¸í•œ ì „ì²´ ì‚­ì œ ì§„í–‰ ì¤‘ ì—¬ë¶€
let clapShrinkInterval = CLAP_DETECTION.SHRINK_INTERVAL; // ì„¤ì •ê°’ ì‚¬ìš©
let clapShrinkCounter = 0; // ë°•ìˆ˜ ì‚­ì œ ì¹´ìš´í„°

// ì˜¤ë””ì˜¤ ê´€ë ¨ ë³€ìˆ˜ë“¤
let audioContext;
let audioAnalyser;
let audioDataArray;
let audioStream;

function setup() {
  createCanvas(windowWidth, windowHeight);
  
  // ì›¹ìº  ì„¤ì •
  video = createCapture(VIDEO, () => {
    // ì›¹ìº  ë¡œë”© í›„ ëª¨ë¸ ì´ˆê¸°í™”
    handpose = ml5.handpose(video, modelReady);
    handpose.on('predict', results => {
      predictions = results;
    });
  });
  video.size(640, 480);
  video.hide();
  
  // ë§ˆì´í¬ ìë™ ì‹œì‘
  startAudioCapture();
}

function modelReady() {
  console.log("Handpose ëª¨ë¸ ì¤€ë¹„ ì™„ë£Œ! ğŸ‘‹");
}

// ì˜¤ë””ì˜¤ ìº¡ì²˜ ì‹œì‘
function startAudioCapture() {
  navigator.mediaDevices.getUserMedia({ audio: true })
    .then(function(stream) {
      console.log("ë§ˆì´í¬ ì¤€ë¹„ ì™„ë£Œ! ğŸ¤");
      
      audioStream = stream;
      audioContext = new (window.AudioContext || window.webkitAudioContext)();
      const source = audioContext.createMediaStreamSource(stream);
      audioAnalyser = audioContext.createAnalyser();
      
      source.connect(audioAnalyser);
      audioAnalyser.fftSize = 256;
      
      const bufferLength = audioAnalyser.frequencyBinCount;
      audioDataArray = new Uint8Array(bufferLength);
      
      console.log("ì˜¤ë””ì˜¤ ìº¡ì²˜ ì‹œì‘ ì™„ë£Œ! ğŸ”Š");
    })
    .catch(function(err) {
      console.error("ë§ˆì´í¬ ì ‘ê·¼ ì˜¤ë¥˜:", err);
    });
}

function windowResized() {
  resizeCanvas(windowWidth, windowHeight);
}

function draw() {
  background(255);

  // 1. ì†ê°€ë½ í¼ì³ì§ ë™ì‘ ê°ì§€ ë° ë§ˆë¦„ëª¨ ìƒì„±
  if (predictions.length > 0) {
    const landmarks = predictions[0].landmarks;
    let fingersUp = [0, 0, 0, 0, 0];

    // ê° ì†ê°€ë½ì´ í´ì¡ŒëŠ”ì§€ í™•ì¸
    if (landmarks[8][1] < landmarks[6][1]) fingersUp[1] = 1; // ê²€ì§€
    if (landmarks[12][1] < landmarks[10][1]) fingersUp[2] = 1; // ì¤‘ì§€
    if (landmarks[16][1] < landmarks[14][1]) fingersUp[3] = 1; // ì•½ì§€
    if (landmarks[20][1] < landmarks[18][1]) fingersUp[4] = 1; // ìƒˆë¼
    if (landmarks[4][0] > landmarks[3][0]) fingersUp[0] = 1; // ì—„ì§€

    const totalFingers = fingersUp.reduce((total, finger) => total + finger, 0);
    
    // ì†ê°€ë½ì´ 3ê°œ ì´ìƒ í´ì§„ ê²½ìš°ì— í¼ì³ì§ ë™ì‘ ê°ì§€ (ë” ìœ ì—°í•˜ê²Œ)
    if (totalFingers >= 3) {
      // ì—„ì§€ì™€ ì•½ì§€(ìƒˆë¼ì†ê°€ë½) ì‚¬ì´ì˜ ê±°ë¦¬ ê³„ì‚°
      let thumbPos = [landmarks[4][0], landmarks[4][1]]; // ì—„ì§€ ëì 
      let pinkyPos = [landmarks[20][0], landmarks[20][1]]; // ì•½ì§€ ëì 
      let currentDistance = dist(thumbPos[0], thumbPos[1], pinkyPos[0], pinkyPos[1]);
      
      // ê°„ë‹¨í•œ ê¸°ì¤€ê±°ë¦¬ ë¡œì§ (ì•ˆì • ì²´í¬ ì œê±°)
      // ê¸°ì¤€ê±°ë¦¬ê°€ ì„¤ì •ë˜ì§€ ì•Šì•˜ìœ¼ë©´ ë°”ë¡œ ì„¤ì •
      if (!isBaselineSet) {
        baselineDistance = currentDistance;
        isBaselineSet = true;

      } else {
        // ê¸°ì¤€ê±°ë¦¬ë¥¼ ì ì§„ì ìœ¼ë¡œ ì—…ë°ì´íŠ¸ (ë…¸ì´ì¦ˆ ì œê±°)
        baselineDistance = baselineDistance * 0.95 + currentDistance * 0.05;
      }
      

      baselineUpdateCounter++;

      // ê¸°ì¤€ ê±°ë¦¬ê°€ ì„¤ì •ëœ í›„ì—ë§Œ ê°ì§€ ì‹œì‘
      if (isBaselineSet) {
        // ì•ˆì •í™” ì‹œê°„ ëŒ€ê¸°
        stabilizationFrames++;
        
        // ë³€í™”ìœ¨ ê³„ì‚° (ì•ˆì •í™” ì™„ë£Œ ì—¬ë¶€ì™€ ê´€ê³„ì—†ì´)
        let distanceChange = currentDistance - baselineDistance;
        let relativeChange = distanceChange / baselineDistance; // ìƒëŒ€ì  ë³€í™”ìœ¨
        
        // ì´ì „ ê±°ë¦¬ì™€ì˜ ë³€í™”ëŸ‰ë„ ê³„ì‚°
        let frameChange = 0;
        if (previousThumbPinkyDistance > 0) {
          frameChange = currentDistance - previousThumbPinkyDistance;
        }
        
        // ê¸°ì¤€ê±°ë¦¬ì— ë”°ë¥¸ ê°€ë³€ì  ë³€í™”ìœ¨ ê³„ì‚°
        let dynamicThreshold = 0;
        if (baselineDistance <= FINGER_DETECTION.BASELINE_MIN) {
          dynamicThreshold = FINGER_DETECTION.SPREAD_THRESHOLD_MIN;
        } else if (baselineDistance >= FINGER_DETECTION.BASELINE_MAX) {
          dynamicThreshold = FINGER_DETECTION.SPREAD_THRESHOLD_MAX;
        } else {
          // ì„ í˜• ë³´ê°„
          let ratio = (baselineDistance - FINGER_DETECTION.BASELINE_MIN) / (FINGER_DETECTION.BASELINE_MAX - FINGER_DETECTION.BASELINE_MIN);
          dynamicThreshold = FINGER_DETECTION.SPREAD_THRESHOLD_MIN - (ratio * (FINGER_DETECTION.SPREAD_THRESHOLD_MIN - FINGER_DETECTION.SPREAD_THRESHOLD_MAX));
        }
        
        // ì•ˆì •í™” í”„ë ˆì„ ì¡°ê±´ ì œê±°í•˜ê³  ë°”ë¡œ ê°ì§€ (ë” ë¹ ë¥¸ ë°˜ì‘)
        // ì¡°ê±´: ê°€ë³€ì  ë³€í™”ìœ¨ + ë°©í–¥ì„± ì²´í¬ + ìµœì†Œ ê±°ë¦¬ ì„ê³„ê°’ + ìµœì†Œ ë³€í™”ëŸ‰
        let isSpreadingDetected = (relativeChange > dynamicThreshold) && 
                                 (currentDistance > previousThumbPinkyDistance) && // ë°©í–¥ì„± ì²´í¬: ì‹¤ì œë¡œ ëŠ˜ì–´ë‚˜ëŠ”ì§€
                                 (currentDistance > FINGER_DETECTION.MIN_DISTANCE) && // ìµœì†Œ ê±°ë¦¬ ì„ê³„ê°’
                                 (Math.abs(currentDistance - previousThumbPinkyDistance) > FINGER_DETECTION.MIN_CHANGE) && // ìµœì†Œ ë³€í™”ëŸ‰
                                 !isSpreading && spreadCooldown === 0;
        
        // ì˜¤ë¯€ë¼ì„ ê°ì§€: ê°€ë³€ì  ë³€í™”ìœ¨ + ë°©í–¥ì„± ì²´í¬ (ì¤„ì–´ë“œëŠ” ë°©í–¥) + ìµœì†Œ ë³€í™”ëŸ‰
        let dynamicClosingThreshold = 0;
        if (baselineDistance <= FINGER_DETECTION.BASELINE_MIN) {
          dynamicClosingThreshold = FINGER_DETECTION.CLOSE_THRESHOLD_MIN;
        } else if (baselineDistance >= FINGER_DETECTION.BASELINE_MAX) {
          dynamicClosingThreshold = FINGER_DETECTION.CLOSE_THRESHOLD_MAX;
        } else {
          // ì„ í˜• ë³´ê°„
          let ratio = (baselineDistance - FINGER_DETECTION.BASELINE_MIN) / (FINGER_DETECTION.BASELINE_MAX - FINGER_DETECTION.BASELINE_MIN);
          dynamicClosingThreshold = FINGER_DETECTION.CLOSE_THRESHOLD_MIN - (ratio * (FINGER_DETECTION.CLOSE_THRESHOLD_MIN - FINGER_DETECTION.CLOSE_THRESHOLD_MAX));
        }
        
        let isClosingDetected = (relativeChange < -dynamicClosingThreshold) && 
                               (currentDistance < previousThumbPinkyDistance) && // ë°©í–¥ì„± ì²´í¬: ì‹¤ì œë¡œ ì¤„ì–´ë“œëŠ”ì§€
                               (currentDistance > FINGER_DETECTION.MIN_CLOSE_DISTANCE) && // ìµœì†Œ ê±°ë¦¬ ì„ê³„ê°’
                               (Math.abs(currentDistance - previousThumbPinkyDistance) > FINGER_DETECTION.MIN_CHANGE) && // ìµœì†Œ ë³€í™”ëŸ‰
                               !isSpreading && spreadCooldown === 0;
        

          
                                  if (isSpreadingDetected) {
              // ì¦‰ì‹œ í¼ì³ì§ìœ¼ë¡œ ì¸ì‹ (ì—°ì† í”„ë ˆì„ ì¡°ê±´ ì œê±°)
              isSpreading = true;
              spreadCount++;
              lastSpreadDistance = currentDistance; // ì†ê°€ë½ í¼ì³ì§ ì‹œì˜ ê±°ë¦¬ ì €ì¥
              console.log("ì†ì´ í¼ì³ì¡ŒìŠµë‹ˆë‹¤! âœ‹ (", spreadCount, "ë²ˆì§¸)");
              spreadCooldown = spreadCooldownFrames;
            } else if (isClosingDetected) {
              // ì¦‰ì‹œ ì˜¤ë¯€ë¼ì„ìœ¼ë¡œ ì¸ì‹ (ì—°ì† í”„ë ˆì„ ì¡°ê±´ ì œê±°)
              console.log("ì†ì´ ì˜¤ë¯€ë¼ì¡ŒìŠµë‹ˆë‹¤! ğŸ¤");
              
              // ë°•ìˆ˜ì²˜ëŸ¼ ìµœê·¼ ë§ˆë¦„ëª¨ë“¤ ì‚­ì œ
              shrinkLatestDiamonds();
              spreadCooldown = spreadCooldownFrames;
            }
      }
      
      // í˜„ì¬ ê±°ë¦¬ë¥¼ ì´ì „ ê±°ë¦¬ë¡œ ì €ì¥
      previousThumbPinkyDistance = currentDistance;
      
      // í¼ì³ì§ì´ ê°ì§€ë˜ë©´ ë§ˆë¦„ëª¨ë“¤ ìƒì„±
      if (isSpreading) {
        // í¼ì³ì¡Œì„ ë•Œì˜ ì†ê°€ë½ ê±°ë¦¬ì™€ ê¸°ì¤€ ê±°ë¦¬ë¥¼ ê¸°ë°˜ìœ¼ë¡œ ë§ˆë¦„ëª¨ ìƒì„±
        generateDiamondGrid(spreadCount, lastSpreadDistance, baselineDistance);
        isSpreading = false; // ìƒíƒœ ì´ˆê¸°í™”
        

      }
    } else {
      // ì†ê°€ë½ì´ 3ê°œ ë¯¸ë§Œì´ë©´ í¼ì³ì§ ìƒíƒœ ì´ˆê¸°í™”
      isSpreading = false;
      consecutiveFrames = 0;
      stabilizationFrames = 0; // ì•ˆì •í™” ì‹œê°„ë„ ë¦¬ì…‹
      // ê¸°ì¤€ê±°ë¦¬ ì—…ë°ì´íŠ¸ ì¹´ìš´í„°ëŠ” ê³„ì† ì¦ê°€ (ì†ì„ ì ê¹ ì ‘ì—ˆë‹¤ í´ëŠ” ê²½ìš° ëŒ€ì‘)
      baselineUpdateCounter++;
    }
  } else {
    // ì†ì´ ì¸ì‹ë˜ì§€ ì•Šìœ¼ë©´ í¼ì³ì§ ìƒíƒœ ì´ˆê¸°í™”
    isSpreading = false;
    consecutiveFrames = 0;
    stabilizationFrames = 0; // ì•ˆì •í™” ì‹œê°„ë„ ë¦¬ì…‹
    // ê¸°ì¤€ê±°ë¦¬ ì—…ë°ì´íŠ¸ ì¹´ìš´í„°ëŠ” ê³„ì† ì¦ê°€ (ì†ì´ ì ê¹ ì‚¬ë¼ì¡Œë‹¤ê°€ ë‹¤ì‹œ ë‚˜íƒ€ë‚˜ëŠ” ê²½ìš° ëŒ€ì‘)
    baselineUpdateCounter++;
  }
  
  // ì¿¨ë‹¤ìš´ ê°ì†Œ
  if (spreadCooldown > 0) {
    spreadCooldown--;
  }

  // 2. ë°•ìˆ˜ ì†Œë¦¬ ê°ì§€
  detectClap();

  // 3. ë°•ìˆ˜ë¡œ ì¸í•œ ì „ì²´ ì‚­ì œ ì²˜ë¦¬
  processClapShrinking();

  // 4. ìˆœì°¨ì  ì‚­ì œ ì²˜ë¦¬
  processShrinkingQueue();

  // 5. ëª¨ë“  ë§ˆë¦„ëª¨ ì—…ë°ì´íŠ¸ ë° ê·¸ë¦¬ê¸°
  updateAndDrawDiamonds();

  // 6. ì†ê°€ë½ í¬ì¸í„° ê·¸ë¦¬ê¸° (ë§ˆë¦„ëª¨ ìœ„ì— í‘œì‹œ)
  checkFingers(predictions, video);
}

function generateDiamondGrid(id, spreadDistance, baseDistance) {
  // ê¸°ì¤€ ê±°ë¦¬(í‰ì†Œ ì† í¬ê¸°)ì™€ í¼ì¹œ ê±°ë¦¬ë¥¼ ëª¨ë‘ ê³ ë ¤í•˜ì—¬ ìœ íš¨ ê±°ë¦¬ ê³„ì‚°
  const effectiveDistance = baseDistance * DIAMOND_GENERATION.BASELINE_WEIGHT + spreadDistance * DIAMOND_GENERATION.SPREAD_WEIGHT;

  // effectiveDistance ê°’ì„ ê¸°ë°˜ìœ¼ë¡œ ë§ˆë¦„ëª¨ í¬ê¸° ê²°ì •
  const maxDiamondSize = width / DIAMOND_GENERATION.MAX_SIZE_RATIO;
  const diamondSize = map(effectiveDistance, DIAMOND_GENERATION.MIN_DISTANCE_MAP, DIAMOND_GENERATION.MAX_DISTANCE_MAP, DIAMOND_GENERATION.MIN_SIZE, maxDiamondSize); 
  const margin = DIAMOND_GENERATION.MARGIN; // ìŒìˆ˜ ë§ˆì§„ìœ¼ë¡œ í™”ë©´ ë°–ê¹Œì§€ ìƒì„±
  const spacing = diamondSize * DIAMOND_GENERATION.SPACING_MULTIPLIER;

  const cols = floor((width - margin * 2) / spacing);
  const rows = floor((height - margin * 2) / spacing);

  const gridWidth = (cols - 1) * spacing;
  const gridHeight = (rows - 1) * spacing;
  const startX = (width - gridWidth) / 2;
  const startY = (height - gridHeight) / 2;

  for (let i = 0; i < cols; i++) {
    for (let j = 0; j < rows; j++) {
      const x = startX + i * spacing;
      const y = startY + j * spacing;
      const diamond = new Diamond(x, y, diamondSize, id);
      diamond.startAnimation();
      diamonds.push(diamond);
    }
  }
}



/**
 * @brief ë°•ìˆ˜ ì†Œë¦¬ë¥¼ ê°ì§€í•˜ì—¬ ëª¨ë“  ë§ˆë¦„ëª¨ë¥¼ ìˆœì°¨ì ìœ¼ë¡œ ì‚­ì œí•©ë‹ˆë‹¤.
 */
function detectClap() {
  if (!audioAnalyser || !audioDataArray) {
    return;
  }
  
  if (clapCooldown > 0) {
    clapCooldown--;
    return;
  }
  
  // ì†Œë¦¬ ë ˆë²¨ ì¸¡ì •
  audioAnalyser.getByteFrequencyData(audioDataArray);
  let sum = 0;
  for (let i = 0; i < audioDataArray.length; i++) {
    sum += audioDataArray[i];
  }
  let level = sum / audioDataArray.length / 255; // 0-1 ë²”ìœ„ë¡œ ì •ê·œí™”
  
  // ë””ë²„ê¹…: ì†Œë¦¬ ë ˆë²¨ ì¶œë ¥ (ë°•ìˆ˜ ê°ì§€ ì‹œì—ë§Œ)
  if (level > clapThreshold * 0.8) {
    console.log("ì†Œë¦¬ ë ˆë²¨:", level.toFixed(3));
  }
  
  if (level > clapThreshold && !isClapShrinking) {
    console.log("ë°•ìˆ˜ ê°ì§€! ğŸ‘ (ë ˆë²¨:", level.toFixed(3), ")");
    startClapShrinking(); // ë°•ìˆ˜ë¡œ ì¸í•œ ì „ì²´ ì‚­ì œ ì‹œì‘
    clapCooldown = clapCooldownFrames;
  }
}

// ê°€ì¥ ìµœê·¼ì— ìƒì„±ëœ ë§ˆë¦„ëª¨ ê·¸ë£¹ì„ ì‚­ì œ (ì† ì˜¤ë¯€ë¦¬ê¸° ì œìŠ¤ì²˜ìš©)
function shrinkLatestDiamonds() {
  if (diamonds.length === 0) return;

  // ê°€ì¥ ìµœì‹  ë²ˆí˜¸ ì°¾ê¸°
  let maxSpreadNumber = -1;
  for (let diamond of diamonds) {
    if (diamond.spreadNumber > maxSpreadNumber) {
      maxSpreadNumber = diamond.spreadNumber;
    }
  }

  // ê°™ì€ ìµœì‹  ë²ˆí˜¸ì˜ ëª¨ë“  ë§ˆë¦„ëª¨ë“¤ ì‚­ì œ
  for (let diamond of diamonds) {
    if (diamond.spreadNumber === maxSpreadNumber && !diamond.isShrinking) {
      diamond.startShrinking();
    }
  }
}

// ë°•ìˆ˜ë¡œ ì¸í•œ ì „ì²´ ì‚­ì œ ì‹œì‘
function startClapShrinking() {
  if (diamonds.length === 0) return;
  
  isClapShrinking = true;
  clapShrinkCounter = 0;
  console.log("ë°•ìˆ˜ ì‚­ì œ ì‹œì‘! ëª¨ë“  ë‹¤ì´ì•„ëª¬ë“œ ê·¸ë£¹ì„ ìˆœì°¨ì ìœ¼ë¡œ ì‚­ì œí•©ë‹ˆë‹¤.");
}

// ë°•ìˆ˜ë¡œ ì¸í•œ ì „ì²´ ì‚­ì œ ì²˜ë¦¬
function processClapShrinking() {
  if (!isClapShrinking || diamonds.length === 0) return;
  
  clapShrinkCounter++;
  if (clapShrinkCounter >= clapShrinkInterval) {
    // ì•„ì§ ì‚­ì œë˜ì§€ ì•Šì€ ë‹¤ì´ì•„ëª¬ë“œ ì¤‘ì—ì„œ ê°€ì¥ ìµœì‹  ê·¸ë£¹ ë²ˆí˜¸ ì°¾ê¸°
    let maxSpreadNumber = -1;
    for (let d of diamonds) {
      if (!d.isShrinking && !d.shouldDelete) {
        if (d.spreadNumber > maxSpreadNumber) {
          maxSpreadNumber = d.spreadNumber;
        }
      }
    }
    
    if (maxSpreadNumber === -1) {
      // ëª¨ë“  ë‹¤ì´ì•„ëª¬ë“œê°€ ì‚­ì œë˜ì—ˆê±°ë‚˜ ì‚­ì œ ì¤‘
      isClapShrinking = false;
      console.log("ë°•ìˆ˜ ì‚­ì œ ì™„ë£Œ! ëª¨ë“  ë‹¤ì´ì•„ëª¬ë“œê°€ ì‚­ì œë˜ì—ˆìŠµë‹ˆë‹¤.");
      return;
    }
    
    // í•´ë‹¹ ê·¸ë£¹ì˜ ëª¨ë“  ë‹¤ì´ì•„ëª¬ë“œ ì‚­ì œ ì‹œì‘
    for (let diamond of diamonds) {
      if (diamond.spreadNumber === maxSpreadNumber && !diamond.isShrinking) {
        diamond.startShrinking();
      }
    }
    
    console.log("ë°•ìˆ˜ ì‚­ì œ: ê·¸ë£¹ #", maxSpreadNumber, "ì‚­ì œ ì‹œì‘");
    clapShrinkCounter = 0; // ì¹´ìš´í„° ë¦¬ì…‹
  }
}

function queueLatestGroupForShrinking() {
  // ì´ë¯¸ ë‹¤ë¥¸ ê·¸ë£¹ì´ ì‚­ì œ ì¤‘ì´ë©´ ìƒˆë¡œ ì‹œì‘í•˜ì§€ ì•ŠìŒ
  if (diamonds.length === 0 || diamondsToShrink.length > 0) return;

  // ì•„ì§ ì‚­ì œë˜ì§€ ì•Šì€ ë‹¤ì´ì•„ëª¬ë“œ ì¤‘ì—ì„œ ê°€ì¥ ìµœì‹  ê·¸ë£¹ ë²ˆí˜¸(spreadNumber) ì°¾ê¸°
  let maxSpreadNumber = -1;
  for (let d of diamonds) {
    if (!d.isShrinking && !d.shouldDelete) {
      if (d.spreadNumber > maxSpreadNumber) {
        maxSpreadNumber = d.spreadNumber;
      }
    }
  }

  if (maxSpreadNumber === -1) return; // ì‚­ì œí•  ê·¸ë£¹ì´ ì—†ìŒ

  // í•´ë‹¹ ê·¸ë£¹ì˜ ëª¨ë“  ë‹¤ì´ì•„ëª¬ë“œë¥¼ ê°€ì ¸ì˜´
  let latestGroup = diamonds.filter(d => d.spreadNumber === maxSpreadNumber);

  // yì¢Œí‘œ, ê·¸ ë‹¤ìŒ xì¢Œí‘œ ìˆœìœ¼ë¡œ ì •ë ¬ (ìœ„ì—ì„œ ì•„ë˜ë¡œ, ì™¼ìª½ì—ì„œ ì˜¤ë¥¸ìª½ìœ¼ë¡œ)
  latestGroup.sort((a, b) => {
    if (a.centerY !== b.centerY) {
      return a.centerY - b.centerY;
    }
    return a.centerX - b.centerX;
  });

  diamondsToShrink = latestGroup;
  shrinkCounter = 0; // ì¹´ìš´í„° ì´ˆê¸°í™”
  console.log("ë°•ìˆ˜ ê°ì§€! ê·¸ë£¹ #", maxSpreadNumber, ": ", diamondsToShrink.length, "ê°œì˜ ë§ˆë¦„ëª¨ë¥¼ ìˆœì°¨ì ìœ¼ë¡œ ì‚­ì œí•©ë‹ˆë‹¤.");
}

function processShrinkingQueue() {
  if (diamondsToShrink.length === 0) return;

  shrinkCounter++;
  if (shrinkCounter >= shrinkInterval) {
    const diamond = diamondsToShrink.shift(); // ëŒ€ê¸°ì—´ì—ì„œ í•˜ë‚˜ êº¼ëƒ„
    if (diamond) {
      diamond.startShrinking();
    }
    shrinkCounter = 0; // ì¹´ìš´í„° ë¦¬ì…‹
  }
}

function updateAndDrawDiamonds() {
  diamonds = diamonds.filter(diamond => !diamond.shouldDelete);

  for (let diamond of diamonds) {
    diamond.update();
    diamond.draw();
  }
}

function easeInOutExpo(x) {
  return x === 0 ? 0 : x === 1 ? 1 : x < 0.5 ? Math.pow(2, 20 * x - 10) / 2 : (2 - Math.pow(2, -20 * x + 10)) / 2;
}

class Diamond {
  constructor(centerX, centerY, size, spreadNumber) {
    this.centerX = centerX;
    this.centerY = centerY;
    this.size = size;
    this.spreadNumber = spreadNumber;
    this.currentSize = 0;
    this.targetSize = size;
    this.animationTime = 0;
    this.animationDuration = ANIMATION.DURATION;
    this.isAnimating = false;
    this.isShrinking = false;
    this.shouldDelete = false;

  }

  draw() {
    push();
    fill(0);
    noStroke();
    translate(this.centerX, this.centerY);
    rotate(PI / 4);
    rectMode(CENTER);
    rect(0, 0, this.currentSize * 1.5, this.currentSize * 1.5);
    pop();
  }

  startAnimation() {
    this.isAnimating = true;
    this.animationTime = 0;
  }

  startShrinking() {
    this.isShrinking = true;
    this.animationTime = 0;
    this.targetSize = this.currentSize;
  }



  update() {
    if (this.isAnimating) {
      this.animationTime++;
      let progress = this.animationTime / this.animationDuration;
      if (progress >= 1) {
        progress = 1;
        this.isAnimating = false;
      }
      this.currentSize = lerp(0, this.targetSize, easeInOutExpo(progress));
    }

    if (this.isShrinking) {
      this.animationTime++;
      let progress = this.animationTime / this.animationDuration;
      if (progress >= 1) {
        progress = 1;
        this.isShrinking = false;
        this.shouldDelete = true;
      }
      this.currentSize = lerp(this.targetSize, 0, easeInOutExpo(progress));
    }
  }
}
