// 9/20 일기
// assured_dist_y_area 값이 음수가 나온다 => 영역 생성 규칙 수정 필욘ㄴ

let width, height

// Circle 관련 변수
let interv_circle, radius, interv_circle_center, circle_list

// Hexa field(중심점을 기준으로 생성된 육각형의 원형 패턴) 관련 변수
let interv_hexa_center, max_hexa_num, assured_dist_x_hexa, assured_dist_y_hexa

// Area 관련 변수
let standard_base, standard_dist, max_area_num
let assured_dist_x_area, assured_dist_y_area, start_point_of_patterns 
let center_x, center_y


function setup() {
  createCanvas(windowWidth, windowHeight);
  noLoop();
  
  // 캔버스 너비, 높이
  width = windowWidth
  height = windowHeight
  center_x = width/2
  center_y = height/2
  console.log("0.0 setup 시작: 초기 변수 설정", "\n",
    "width", width, "\n",
    "height", height, "\n",
    "center_x", center_x, "\n",
    "center_y", center_y, "\n",
  )
  // Circle 관련 변수 설정
  interv_circle = 1
  radius = 6
  interv_circle_center = 2*radius + interv_circle
  circle_list = []
  console.log("0.1 setup 시작: Circle 관련 변수 설정", "\n",
    "interv_circle", interv_circle, "\n",
    "radius", radius, "\n",
    "interv_circle_center", interv_circle_center, "\n",
    "circle_list", circle_list, "\n",
  )

  // Hexa field(중심점을 기준으로 생성된 육각형의 원형 패턴) 관련 변수 설정
  max_hexa_num = 3
  interv_hexa_center = (interv_circle_center*max_hexa_num + radius)*2 + interv_circle
  assured_dist_x_hexa = 0
  assured_dist_y_hexa = 0  
  console.log("0.2 setup 시작: Hexa field 관련 변수 설정", "\n",
    "max_hexa_num", max_hexa_num, "\n",
    "interv_hexa_center", interv_hexa_center, "\n",
    "assured_dist_x_hexa", assured_dist_x_hexa, "\n",
    "assured_dist_y_hexa", assured_dist_y_hexa, "\n",
  )

  // Area 관련 변수 설정
  standard_base = width < height ? width : height;
  standard_dist = standard_base / 6
  max_area_num = 3;
  assured_dist_x_area = width - 2*(standard_dist+ max_area_num*interv_hexa_center)
  assured_dist_y_area = height - 2*(standard_dist+ max_area_num*interv_hexa_center)
  start_point_of_patterns = []
  if (assured_dist_y_area < 0 || assured_dist_x_area < 0){
    console.log("경고: assured_dist 값이 음수입니다:", "\n",
      "assured_dist_x_area", assured_dist_x_area, "\n",
      "assured_dist_y_area", assured_dist_y_area, "\n",
      "assured_dist: width - 2*(standard_dist+ max_area_num*interv_hexa_center)", "\n",
      "width", width, "height", height, "\n",
      "standard_dist", standard_dist, "\n",
      "max_area_num", max_area_num, "\n",
      "interv_hexa_center", interv_hexa_center, "\n",
    )
  }
  
  console.log("0.3 setup 시작: Area 관련 변수 설정", "\n",
    "standard_base", standard_base, "\n",
    "standard_dist", standard_dist, "\n",
    "max_area_num", max_area_num, "\n",
    "assured_dist_x_area", assured_dist_x_area, "\n",
    "assured_dist_y_area", assured_dist_y_area, "\n",
  )

  // 패턴 영역 구분 각 패턴 시작작점 생성
  console.log("1. 영역 구분을 위한 꼭짓점 생성 시작")
  for (let i = 0; i <= max_area_num; i++){
    console.log(`${i}번째 영역 구분을 위한 꼭짓점 생성 시작`)
    start_point_of_patterns.push(create_hexa_field(create_area = true, center_x, center_y, i, max_area_num, assured_dist_x_area, assured_dist_y_area, interv_hexa_center, interv_hexa_center))
  }
  console.log("1. 영역 구분을 위한 꼭짓점 생성 완료")

  // 중심점 주변의 원형 점 생성
  // 영역에 해당하는 중심점 리스트 꺼내기
  console.log("2. 꼭짓점 주변의 원형 점 생성 시작")
  for (let i = 0; i < max_area_num; i++){
    start_points = start_point_of_patterns[i]
    console.log(`${i}번째 영역에 해당하는 중심점 꺼내기`)
    // 영역에 해당하는 중심점 꺼내기
    for (let j = 0; j < length(start_points); j++){
      start_point = start_points[j]

      // 중심점 주변으로 육각 사이즈의 원형 패턴 생성
      for (let k = 0; k < max_hexa_num; k++){
        hexa_field = create_hexa_field(create_area = False, start_point[0], start_point[1], k, max_hexa_num, assured_dist_x_hexa, assured_dist_y_hexa, interv_circle_center, interv_circle_center)

        for (let l = 0; l < length(hexa_field); l++){
          circle_list.push(hexa_field[l])
        }
      }
    }
  }
}

function draw() {
  background(220);

  noStroke();
  fill(255);

  for (let circle of circle_list){
    circle.draw();
  }


}





//중복이 있다 코드에 이걸 이용하자
function create_hexa_field(create_area, center_x, center_y, index, max_index, assured_x_dist, assured_y_dist, x_dist, y_dist){

  // 육각형 꼭짓점 생성
  point_list = []
  console.log("1.1. create_hexa_field: 육각형 꼭짓점 생성 시작", "\n",
    "Center_x: ", center_x, '\n', 
    "Center_y: ", center_y, '\n', 
    "Index: ", index, '\n', 
    "Max_index: ", max_index, '\n', 
    "Assured_x_dist: ", assured_x_dist, '\n', 
    "Assured_y_dist: ", assured_y_dist, '\n', 
    "X_dist: ", x_dist, '\n', 
    "Y_dist: ", y_dist, '\n')
  let [point1, point2, point3, point4, point5, point6] = create_hexa_point(create_area, center_x, center_y, index, max_index, assured_x_dist, assured_y_dist, x_dist, y_dist)
  console.log("1.2. create_hexa_field: 육각형 꼭짓점 생성결과", "\n", "point1:", point1, '\n', "point2:", point2, '\n', "point3:", point3, '\n', "point4:", point4, '\n', "point5:", point5, '\n', "point6:", point6)
  // 육각형 꼭짓점 사이의 점점 생성
  console.log("2.1. create_linear_point: 육각형 꼭짓점 사이의 점 생성 시작")
  // point1 -> point2
  point_list.push(create_linear_point(point1, point2, x_dist, y_dist))
  // point2 -> point3
  point_list.push(create_linear_point(point2, point3, x_dist, y_dist))
  // point3 -> point4
  point_list.push(create_linear_point(point3, point4, x_dist, y_dist))
  // point4 -> point5
  point_list.push(create_linear_point(point4, point5, x_dist, y_dist))
  // point5 -> point6
  point_list.push(create_linear_point(point5, point6, x_dist, y_dist))
  // point6 -> point1
  point_list.push(create_linear_point(point6, point1, x_dist, y_dist))
  return point_list
}

function create_hexa_point(create_area, center_x, center_y, index, max_index, assured_x_dist, assured_y_dist, x_dist, y_dist){
  /*
  중심점을 기준으로 index*dist만큼 떨어진 육각형 점을 생성
  dist는 area 생성 or hexa field 생성 규칙에서 사용하는 main 거리(같은 거 아는데, 나중에 다양한 변형을 하고 싶은 경우를 대비해서 여지를 남김김)
  */
  let indexed_x_dist, indexed_y_dist
  if (create_area){
    indexed_x_dist = (index+1)*x_dist;
    indexed_y_dist = (index+1)*y_dist;
  }
  else{
    indexed_x_dist = index*x_dist;
    indexed_y_dist = index*y_dist;
  }
  
  let point1_x = center_x - assured_x_dist/2 - indexed_x_dist;
  let point1_y = center_y;
  let point2_x = point1_x + indexed_x_dist/2;
  let point2_y = point1_y - assured_y_dist/2 - indexed_y_dist;
  let point3_x = point2_x + indexed_x_dist;
  let point3_y = point2_y;
  let point4_x = point3_x + indexed_x_dist/2;
  let point4_y = point1_y;
  let point5_x = point3_x;
  let point5_y = point4_y - indexed_y_dist;
  let point6_x = point5_x - indexed_x_dist;
  let point6_y = point5_y;
  
  return [[point1_x, point1_y], [point2_x, point2_y], [point3_x, point3_y], [point4_x, point4_y], [point5_x, point5_y], [point6_x, point6_y]]
} 

function create_linear_point(point_a, point_b, x_dist, y_dist){
  linear_point_list = []
  x_direction = point_b[0] - point_a[0] > 0 ? true : false
  y_direction = point_b[1] - point_a[1] > 0 ? true : false

  if (x_direction){
    x_dist = x_dist
  }
  else{
    x_dist = -x_dist
  }
  if (y_direction){
    y_dist = y_dist
  }
  else{
    y_dist = -y_dist
  }

  for (let i = point_left_x; i <= point_right_x; i += x_dist){
    for (let j = point_left_y; j <= point_right_y; j += y_dist){
      linear_point_list.push([i, j])
      console.log("2.2. create_linear_point: 육각형 꼭짓점 사이의 점 생성 결과", "\n", "linear_point_list:", linear_point_list)
    }
  }
  return linear_point_list
}


class circle{
  constructor(x, y, radius, hexa_num, area_num){
    this.x = x;
    this.y = y;
    this.radius = radius;

    this.hexa_num = 0
    this.area_num = 0
  }

  draw(){
    circle(this.x, this.y, this.radius * 2);
  }
} 
