/******************
Code by Vamoss
Original code link:
https://www.openprocessing.org/sketch/751983

Author links:
http://vamoss.com.br
http://twitter.com/vamoss
http://github.com/vamoss
******************/

//Inspired by Felix Auer
//http://www.felixauer.com/javascript/difeqrk.html

// 파티클들을 저장하는 배열,  파티클 색상을 저장하는 배열
let blobs = [];
let colors;

//  파티클 움직임의 변화를 제어하는 변수, 그래픽 요소의 크기와 중심을 계산하는 변수들
let variation = 0;
let xScale, yScale, centerX, centerY;

//자동 변화를 위한 변수들
let changeDuration = 3000;
let lastChange = 0;

function setup() {
  createCanvas(windowWidth, windowHeight);
  textAlign(CENTER, CENTER);

  xScale = width / 20;
  yScale = height / 20 * (width / height);

  centerX = width / 2;
  centerY = height / 2;

  colors = [color("#581845"), color("#900C3F"), color("#C70039"), color("#FF5733"), color("#FFC30F")];
}

function draw() {
  /*
  //DEBUG
  textSize(20);
  noStroke();
  fill(255);
  ellipse(centerX, centerY, 60, 60);
  fill(0);
  text(variation, centerX, centerY-10);
  text(length, centerX, centerY+10);
  */

  if (mouseIsPressed) {
    for (let i = 0; i < 20; i++) {
      let x = mouseX + random(-100, 100);
      let y = mouseY + random(-100, 100);
      var blob = {
        // 캔버스 상에 표시될 위치(하지만 어느 캔버스에서도 동일한 효과일 수 있게 스케일링)
        x: getXPos(x),
        y: getYPos(y),

        size: random(1, 5),
        lastX: x,
        lastY: y,
        color: colors[floor(random(colors.length))],

        // 파티클의 움직임 방향 설정
        // 0.5 이상인 경우 1, 아닌 경우 -1
        direction: random(0.1, 1) * (random() > 0.5 ? 1 : -1)
      };
      blobs.push(blob);
    }
  }

  let length = blobs.length;
  if (length == 0) {
    background("#1a0633");
    noStroke();
    fill(255);
    textSize(40);
    text("Press to emmit particles", centerX, centerY);
    return;
  }

  // background 역할
  noStroke();
  fill(26, 6, 51, 10);
  rect(0, 0, width, height);

  //auto change
  // 현재 시간을 밀리초 단위로 가져와 time 변수에 저장(1초 = 1000millis, 이며 최초 부르실 0)
  // 3초마다 variation 변화
  let time = millis();
  if (time - lastChange > changeDuration) {
    lastChange = time;
    //variation++;
    if (variation > 11) variation = 0;
  }

  // deltaTime: 이전 프레임과 현제 프레임 간의 시간 간격을 밀리초 단위로 표시
  var stepsize = deltaTime * 0.005;
  for (var i = length - 1; i >= 0; i--) {
    let blob = blobs[i];

    //1단계
    // var x,y는 초기 위치
    var x = getSlopeX(blob.x, blob.y);
    var y = getSlopeY(blob.x, blob.y);

    // blob.x, blol.y는 신규 좌표(기존좌표 기준 조금 이동)
    blob.x += blob.direction * x * stepsize;
    blob.y += blob.direction * y * stepsize;

    // 초기위치인 x,y 갱신
    x = getXPrint(blob.x);
    y = getYPrint(blob.y);
    stroke(blob.color);
    strokeWeight(blob.size);
    line(x, y, blob.lastX, blob.lastY);
    blob.lastX = x;
    blob.lastY = y;

    const border = 200;
    if (x < -border || y < -border || x > width + border || y > height + border) {
      blobs.splice(i, 1);
    }
  }
}

function getSlopeY(x, y) {
  switch (variation) {
    case 0: return Math.sin(x);
    case 1: return Math.sin(x * 5) * y * 0.3;
    case 2: return Math.cos(x * y);
    case 3: return Math.sin(x) * Math.cos(y);
    case 4: return Math.cos(x) * y * y;
    case 5: return Math.log(Math.abs(x)) * Math.log(Math.abs(y));
    case 6: return Math.tan(x) * Math.cos(y);
    case 7: return -Math.sin(x * 0.1) * 3;//orbit
    case 8: return (x - x * x * x) * 0.01;//two orbits
    case 9: return -Math.sin(x);
    case 10: return -y - Math.sin(1.5 * x) + 0.7;
    case 11: return Math.sin(x) * Math.cos(y);
  }
}

function getSlopeX(x, y) {
  switch (variation) {
    case 0: return Math.cos(y);
    case 1: return Math.cos(y * 5) * x * 0.3;
    case 2:
    case 3:
    case 4:
    case 5:
    case 6: return 1;
    case 7: return Math.sin(y * 0.1) * 3;//orbit
    case 8: return y / 3;//two orbits
    case 9: return -y;
    case 10: return -1.5 * y;
    case 11: return Math.sin(y) * Math.cos(x);
  }
}
// getXPos(x) 함수는 x 좌표를 받아들이고, 이를 캔버스의 중심을 기준으로 스케일링한 값을 반환
// 캔버스의 중심을 (0, 0)으로 생각하고, x와 y 좌표를 이 중심으로부터 얼마나 떨어져 있는지를 계산합니다.
function getXPos(x) {
  return (x - centerX) / xScale;
}
function getYPos(y) {
  return (y - centerY) / yScale;
}


// 이 함수들은 변환된 좌표를 다시 실제 화면의 좌표로 되돌려줍니다.
// 함수는 x 좌표를 받아들이고, 이를 실제 화면에서의 좌표값으로 변환
function getXPrint(x) {
  return xScale * x + centerX;
}
function getYPrint(y) {
  return yScale * y + centerY;
}






